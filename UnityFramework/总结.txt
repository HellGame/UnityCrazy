框架
1、恰当的使用单例
2、创建类的时候尽量不继承MonoBehavior
3、界面之间传递消息的时候，使用委托模式来减少依赖（此条为个人经验）


一.架构必须符合安全性。
二.分离美术与程序的工作
三.消除程序员代码上的交点 a
四.分层结构设计全面可扩展 a

二.整个架构只有一个入口点 a
三.动态资源生成与管理。 a
四.独立模块以DLL形式存在 
五.尽量编写方便的工具 b

输入输出用一个单例 InputController 用 委托实现分发 todo
全局变量用一个单例 GlobalManager.cs todo


8.要充分的管理GUI，不然过多的GUI会导致内存加速增长，
而每次都销毁不用的GUI则会让IO过于频繁降低运行速度。
我的方法是找到两者间的中间态，给予隐藏的GUI一个缓冲带,
当每次某各GUI进行隐藏时判断是否有需要销毁的GUI。或者也可以这么做，每时每刻去监控隐藏的GUI，哪些GUI内存时间驻留过长就销毁。关于内存优化问题，

6.拆分GUI层级，层级越高，显示越靠前。层级的正确拆分能有效管理GUI的显示方式。

/// <summary>
/// GUI层级
/// </summary>
public enum GUILAYER
{
    GUI_BACKGROUND = 0, //背景层
    GUI_MENU,           //菜单层0
    GUI_MENU1,           //菜单层1
    GUI_PANEL,          //面板层
    GUI_PANEL1,         //面板1层
    GUI_PANEL2,         //面板2层
    GUI_PANEL3,         //面板3层
    GUI_FULL,           //满屏层
    GUI_MESSAGE,        //消息层
    GUI_MESSAGE1,        //消息层
    GUI_GUIDE,           //引导层
    GUI_LOADING,        //加载层
}




3d
1.特效是对画面效果最最有影响的部分，尽量少使用粒子或者将粒子的数量减少到最小。
2.尽量减少灯光的使用，而使用烘培后的图来代替。但烘培贴图用多了内存就爆，所以还是要谨慎。
3.使用静态批处理，将那些不动的物体设置为静态，以降低CPU。但unity说静态批处理会增加更多内存。这里也需要权衡。
4.尽可能的将多个物体使用同一个材质球。这样可以有效降低drawcall。虽然在实际操作中比较困难，但还是需要做的。
5.使用动态批处理。将多个不动的，使用相同材质球的物体合并mesh。这个更加有效得降低drawcall。
2d
1.将同一页面或者同一类型的ui图合并成一个图集，减少渲染时的drawcall。
2.将需要alpha和不需要alpha的图拆分开来做图集，不需要alpha的的图集可以大幅度的做压缩处理，因为这些图像压缩后看起来不会太糟糕。而有alpha的图集压缩会使得图像差别比较大。这样可以减少内存占用。
3.在以上基础上，尽量将图集做压缩处理。只有那些需要高精度的图才不做压缩。这样做可以大幅度减少内存占用。
3.图集不宜过大，过大的图集，不要把很多个GUI都放在一个图集里，在UI显示时加载资源IO速度会非常慢。我尝试了各种方式来管理图集，例如每个GUI一个图集，大雨300*100宽度的图不做图集，抑或一个系统模块2个图集，甚至我有尝试过以整个游戏为单位划分公共图集，按钮图集，头像图集，问题图集，但这种方式最终以图集过大IO过慢而放弃，这些图集的管理方式都是应项目而适应的，并没有固定的方式，最主要是你怎么理解程序读取资源时的IO操作时间。
4 最最好的在安卓机子上启用RGBA16方式，因为这个是适应所有机型的，并且比32位占用量少一半，但也需要因项目而异，只是推荐使用的格式，可以多用。

二.减少占用空间大小。
1.我使用的是动态资源的加载方式WWW方式。所以在导出资源时我使用BuildAssetBundleOptions.DisableWriteTypeTree 的打包方式，减少包的大小。
2.对每张Texture，都设置对图片进行压缩。

3.让美术减少模型面片数，并在fbx模型设置中，设置对模型进行压缩

4.让美术减少动画帧数，并在动画设置中，设置对动画进行压缩

内存
2.GUI部分在GUIManager管理类中增加 对GUI进行定时检查的部分，对不展示的GUI资源进行释放。对于一些ui出现时的释放资源卡顿的问题，可以在ui出现后1秒再释放资源。其他策略可以自己想下，有效就好。
3.因为有些时候一次性加载的资源过多，内存一下子会膨胀，IO过慢导致奔溃，所以我选择资源异步加载。使得加载这么多资源不那么可怕，并且平滑。
4.内存释放：这里有个重点，我重点测试了一下内存释放的忽视点。在我们利用ngui,或者2dtoolkit进行gui编程时，在释放其gui节点时通常会忘记将gui引用置为null，这就导致了内存泄漏。一些不再使用的贴图或者实例数据仍然继续存留在内存中。对于是否有需要将这些gui变量置为null的说法，我还做了一个实验。

使用.ogg对音频压缩，其他的音频格式在发布打包时将被作为非压缩的PCM音频格式存储在包内。
每个rigidbody都消耗计算，所以越少越理想

关于PlayerPref的操作，统一写成静态类的get/set模式，程序中哪里要用则直接读写。
那么拖入场景的prefab数量一定要少。
多写class 少些monobehavior

2.FixedUpdate方法里尽可能保持少的逻辑。这些逻辑可以被调用大约50-100次每秒在每个有效脚本的每个物体里，所以他们是优化的重要目标。如果某些逻辑确实需要在渲染更新后执行再把这些代码放进update方法里去。
尽可能把一些物体上的脚本关掉当不再需要他们的时候。如果你的游戏有一个大型的场景，里面的怪物在几公里远的地方，你可以关掉他的AI脚本直到摄像头靠近他们时再开启。这里有个好方法去开关它们，就是使用gameObject.SetActiveRecursively(false)并且设置球形和方形碰撞体为触发器(trigger)。

3.小心空的Update方法。当使用资源菜单创建新的脚本时他们包含了空的Update方法。去掉它如果你不需要它的话，因为它会带来一些(少量的)性能消耗。这个性能消耗点应用所有在MonoBehaviour脚本里的重载方法，以Update和FixedUpdate为主要的目标。


9.另外关于图标，像头像，物品，数量过多的，可以用打成几个图集，按一定规则进行排列，减小文件大小减少一次性读取的IO时间。

10.尽量减少不必要的UI更改，NGUI一旦有UI进行更改，它就得重新绘制MESH和贴图，比起cocos2d耗得CPU大的多。

11.如果可以不用动态字体就不要用动态字体，因为动态字体每次都会做IO操作读取相应的图片，这个是NGUI一个问题，费cpu，费内存。

12.设置脚本执行次序，在U3D的Project setting->Script Execution Order 中。由于NGUI以UIPanel为主要渲染入口，所以，所有关于游戏渲染处理的程序最好放在渲染之后，也就是UIPanel之后。UIPanel以LateUpdate为接口入口，所以关于渲染方面的程序还得斟酌是否方在LateUpdate里。